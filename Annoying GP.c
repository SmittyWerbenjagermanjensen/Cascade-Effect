#pragma config(Sensor, S2,     SENSOR_GYRO_X,  sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          Right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          Left,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*const tSensors GyroSensor = (tSensors) S1;
#define offset 603
long Gyro_value;

task main() {
	while(true) {
	Gyro_value = SensorValue(GyroSensor)-offset;
	nxtDisplayCenteredTextLine(3, "%f", Gyro_value);
	}
}
*/
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!

#include "drivers\hitechnic-gyro.h";
float thetaX = 0;
unsigned int t = 0;
float avgGyroX = 0;
string yaw = "YAW:";
bool finished = false;

	task main(){
		//nxtDisplayCenteredTextLine(2, "%s", "Starting:")
	 // thetaX = (int)(rand()*180-90);
		while (avgGyroX < 570 || avgGyroX > 630) {
			PlaySound(soundLowBuzz);
	  	for (int i = 0; i < 1000; i ++) {
				avgGyroX += SensorValue[SENSOR_GYRO_X];
				wait1Msec(1);
  		}
  		avgGyroX = avgGyroX/1000;
	  }
  	PlayTone(1500, 5);
		for (int i = 0; i < 15; i++) {
			while(!finished) {
				motor[Right] = 25;
				motor[Left] = -25;
				t++;
				wait1Msec(1);
				thetaX = thetaX + ((float)SensorValue[SENSOR_GYRO_X]-avgGyroX) * time1[T1] / 1000.0;
				ClearTimer(T1);


				//int refX = (int)(thetaX+180)%360 - 180;

				eraseDisplay();
				nxtDisplayTextLine(2, "%s", yaw);
				nxtDisplayCenteredTextLine(5, "%d", thetaX);

				if (abs((int)(thetaX)) >= 10) {
					finished = true;
					//motor[Right] = 0;
					//motor[Left] = 0;
				}

				/*if ((int)sqrt(refY*refY + refX*refX) == 0)
					PlayTone(1500, 5);
				else if ((t*10)%(int)sqrt(refY*refY + refX*refX) == 0)
			  	PlayTone(1000, 5);*/
			}
			finished = false;
			thetaX = 0;
		}
		motor[Right] = 0;
		motor[Left] = 0;
	}
