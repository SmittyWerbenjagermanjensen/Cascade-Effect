#pragma config(Sensor, S1,     SENSOR_GYRO_Y,    sensorI2CHiTechnicGyro)
#pragma config(Sensor, S2,     SENSOR_GYRO_X,    sensorI2CHiTechnicGyro)
/*const tSensors GyroSensor = (tSensors) S1;
#define offset 603
long Gyro_value;

task main() {
	while(true) {
	Gyro_value = SensorValue(GyroSensor)-offset;
	nxtDisplayCenteredTextLine(3, "%f", Gyro_value);
	}
}
*/
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!

//#include "drivers\hitechnic-gyro.h";
float thetaY = 0;
float thetaX = 0;
unsigned int t = 0;
float avgGyroY = 0;
float avgGyroX = 0;
string yaw = "YAW:";
string pitch = "PITCH:";



	task main(){
		//nxtDisplayCenteredTextLine(2, "%s", "Starting:");
	  thetaY = (int)(rand()*360-180);
	  thetaX = (int)(rand()*180-90);
		while (avgGyroY < 570 || avgGyroY > 630 || avgGyroX < 570 || avgGyroX > 630) {
			PlaySound(soundLowBuzz);
	  	for (int i = 0; i < 1000; i ++) {
				avgGyroY += SensorValue[SENSOR_GYRO_Y];
				avgGyroX += SensorValue[SENSOR_GYRO_X];
				wait1Msec(1);
  		}
  		avgGyroY = avgGyroY/1000;
  		avgGyroX = avgGyroX/1000;
	  }
  	PlayTone(1500, 5);

		while(true) {
			t++;
			wait1Msec(100);
			thetaY = thetaY + ((float)SensorValue[SENSOR_GYRO_Y]-avgGyroY) * time1[T1] / 1000.0;
			thetaX = thetaX + ((float)SensorValue[SENSOR_GYRO_X]-avgGyroX) * time1[T1] / 1000.0;
			ClearTimer(T1);

			int refY = (int)(thetaY+180)%360 - 180;
			int refX = (int)(thetaX+180)%360 - 180;

			eraseDisplay();
			nxtDisplayTextLine(2, "%s", yaw);
			nxtDisplayCenteredTextLine(3, "%d", refY);
			nxtDisplayTextLine(4, "%s", pitch);
			nxtDisplayCenteredTextLine(5, "%d", refX);

			if ((int)sqrt(refY*refY + refX*refX) == 0)
				PlayTone(1500, 5);
			else if ((t*10)%(int)sqrt(refY*refY + refX*refX) == 0)
		  	PlayTone(1000, 5);
		}
	}
